#!/bin/sh

# activate pool for iocage
# intended for automation tool
__activate () {
    local _pool

    _pool=${1}

    __set_dataset_ioc_prop active=yes ${_pool}
}

__deactivate () {
    local _pool

    _pool=${1}

    __unset_dataset_ioc_prop active ${_pool}
}

__create_basejail () {
    local _release _fs

    _release=${1}

    echo
    echo -n "Creating basejail ZFS datasets..."

    for _fs in ${bfs_list} ; do
        zfs create -o compression=lz4 -p \
            ${pool}/iocage/base/${_release}/root/${_fs}
    done

    echo " OK"
}

__reclone_basejail () {
    local _dataset _fulluuid _jail_release _fs

    _dataset=${1}
    
    _fulluuid=$(__get_dataset_ioc_prop host_hostuuid ${_dataset})
    _jail_release=$(__get_dataset_ioc_prop release ${_dataset})

    zfs destroy -rRf ${pool}/iocage/base@${_fulluuid}
    zfs snapshot -r  ${pool}/iocage/base@${_fulluuid}

    echo "* ${_fulluuid} is a basejail, re-cloning jail.."

    # Re-clone required filesystems
    for _fs in ${bfs_list} ; do
        # echo "  re-cloning: ${_dataset}/root/${_fs}"
        zfs clone \
            ${pool}/iocage/base/${_jail_release}/root/${_fs}@${_fulluuid} \
            ${_dataset}/root/${_fs}
    done
}

# This creates jails ---------------------------------------------------
__create_jail () {
    local _flag _dataset _fs_list _zfsconfig _fs _dir

    zfs list -r ${pool}/iocage/releases | grep -q ${release} ||
        __fatal_error "Release ${release} not found locally, run fetch first."

    _flag=${1}

    _dataset=${pool}/iocage/jails/${uuid}

    case "${_flag}" in
        # Create a cloned jail.
        -c)
            _fs_list=$(zfs list -rHo name ${pool}/iocage/releases/${release})
            _zfsconfig=$(__configure_jail generate)

            zfs snapshot -r ${pool}/iocage/releases/${release}@${uuid}

            for _fs in ${_fs_list} ; do
                cfs=$(echo ${_fs} | sed s#/releases/${release}#/jails/${uuid}#g)
                eval "zfs clone ${_zfsconfig} ${_fs}@${uuid} ${_cfs}"
            done
            ;;

        # Create an empty jail.
        -e)
            _zfsconfig=$(__configure_jail generate)

            eval "zfs create -p ${_zfsconfig} ${_dataset}"
            zfs create -p ${_dataset}/root
            ;;

        # Create a basejail.
        -b)
            export type="basejail"
            _zfsconfig=$(__configure_jail generate)

            zfs snapshot -r ${pool}/iocage/base@${uuid}
            eval "zfs create -p ${_zfsconfig} ${_dataset}"
            zfs create -o compression=lz4 -p ${_dataset}/root/usr

            for _fs in ${bfs_list} ; do
                zfs clone -o compression=lz4 -o readonly=on \
                    ${pool}/iocage/base/${release}/root/${_fs}@${uuid} \
                    ${_dataset}/root/${_fs}
            done

            for _dir in ${bdir_list} ; do
                cp -a ${iocroot}/base/${release}/root/${_dir} \
                   ${iocroot}/jails/${uuid}/root/${_dir}
            done
            ;;

        # Create a standard jail.
        *)
            zfs snapshot -r ${pool}/iocage/releases/${release}@${uuid}
            zfs send     -R ${pool}/iocage/releases/${release}@${uuid} \
            | zfs recv      ${_dataset}
            zfs destroy  -r ${pool}/iocage/releases/${release}@${uuid}
            zfs destroy  -r ${_dataset}@${uuid}

            __configure_jail ${_dataset}
            ;;
    esac

    touch ${iocroot}/jails/${uuid}/fstab

    # Remove any clone snapshots carried over from the RELEASE datasets.
    __snapremove ${_dataset} ALL

    # Write the default rc.conf to the jail, except for empty jails.
    if [ "${_flag}" != "-e" ] ; then
        echo "hostname=\"${hostname}\"" > ${iocroot}/jails/${uuid}/root/etc/rc.conf
        __jail_rc_conf >> ${iocroot}/jails/${uuid}/root/etc/rc.conf
        __resolv_conf ${_dataset} > ${iocroot}/jails/${uuid}/root/etc/resolv.conf
    else
        echo ${uuid}
    fi

    zfs create -o compression=lz4 ${pool}/${jail_zfs_dataset}
    zfs set mountpoint=none ${pool}/${jail_zfs_dataset}
    zfs set jailed=on ${pool}/${jail_zfs_dataset}

    # Install extra packages.
    # This requires working resolv.conf in jail
    if [ "${pkglist}" != "none" ] ; then
        __hack88_mount ${_dataset}
        __pkg_install "${iocroot}/jails/${uuid}/root"
    fi
}

# Cloning jails ----------------------------------------------------------
__clone_jail () {
    local _dataset _snapshot _zfsconfig _fs_list _fs _cfs
    local _clone_dataset _mountpoint

    _dataset=${1}
    _snapshot=${2:-@${uuid}}

    _zfsconfig=$(__configure_jail generate)
    _fs_list=$(zfs list -rHo name ${_dataset})

    if ! zfs list ${_dataset}${_snapshot} >&- 2>&- ; then
        zfs snapshot -r ${_dataset}${_snapshot}
    fi

    for _fs in ${_fs_list} ; do
        _cfs=$(echo ${_fs} | sed s#${_dataset}#${pool}/iocage/jails/${uuid}#g)
        if echo ${_cfs} | grep -q data$ ; then
            zfs clone -o mountpoint=none -o jailed=on ${_fs}${_snapshot} ${_cfs}
        else
            eval "zfs clone ${_zfsconfig} ${_fs}${_snapshot} ${_cfs}"
        fi
    done

    _clone_dataset=${pool}/iocage/jails/${uuid}
    _mountpoint=$(__get_dataset_zfs_prop mountpoint ${_clone_dataset})

    mv ${_mountpoint}/fstab ${_mountpoint}/fstab.${uuid}
    touch ${_mountpoint}/fstab

    sed -E -e "s/[a-zA-Z0-9]{8,}-.*-.*-.*-[a-zA-Z0-9]{12,}/${uuid}/g" \
        -i '' ${_mountpoint}/root/etc/rc.conf
}

# Destroy jails --------------------------------------------------------------
__destroy_jail () {
    local _dataset _force _fulluuid _origin _jail_type

    _dataset=${1}
    _force=${2}
    
    _fulluuid=$(__get_dataset_ioc_prop host_hostuuid ${_dataset})
    if __is_running ${_fulluuid} ; then
        if [ "${_force}" -eq 1 ] ; then
            __stop_jail ${_dataset}
        else
            __fatal_error "Jail is still up and running (use -f to force)!"
        fi
    fi

    _origin=$(__get_dataset_zfs_prop origin ${_dataset})
    _jail_type=$(__get_dataset_ioc_prop type ${_dataset})

    echo "  Destroying: ${_fulluuid}"

    ## FIXME: Symlinks to tags currently disabled, see lib/ioc-common for
    ## comments on __link_tag ()
    #__unlink_tag ${_dataset}
    zfs destroy -fr ${_dataset}

    if [ "${_origin}" != "-" ] ; then
        echo "  Destroying clone origin: ${_origin}"
        zfs destroy -r ${_origin}
    fi

    if [ "${_jail_type}" == "basejail" ] ; then
        zfs destroy -fr ${pool}/iocage/base@${_fulluuid}
    fi
}

__destroy_all () {
    local _force _jails _jail

    _force=${1}
    
    _jails=$(__find_jail ALL)

    echo "  Destroying all jails"

    for _jail in ${_jails} ; do
        __destroy_jail ${_jail} ${_force}
    done

    rm -f ${iocroot}/tags/*
}

# check if our datasets exist, if not create them
# fixes https://github.com/iocage/iocage/issues/80
__check_filesystems () {
    local _missing _filesystems _fs

    _missing=0
    _filesystems="${iocroot}
                  ${iocroot}/jails
                  ${iocroot}/.defaults
                  ${iocroot}/download
                  ${iocroot}/releases"

    for _fs in ${_filesystems} ; do
        zfs get -H creation ${pool}${_fs} > /dev/null 2>&1
        if [ ${?} -ne 0 ] ; then
            _missing=1
            echo "  INFO: Creating ${pool}${_fs}"
            zfs create -p ${pool}${_fs}
            zfs set mountpoint=${_fs} ${pool}${_fs}
            if [ ${_fs} == ${iocroot}/.defaults ] ; then
                __update_defaults_ioc_properties
            fi
        fi
    done

    if [ ${_missing} -gt 0 ] ; then
        zfs mount -a
    fi
}

# Check that all our jails are compatible with this version of iocage.
#
# If a jail isn't compatible, make it compatible.
#
# Version is stored per-jail so that when jails are transferred between
# different versions of iocage, we can detect and fix missing properties without
# requiring manual intervention.
__check_all_ioc_version () {
    local _mismatches _jail _uuid

    # This is only slightly complicated because the version string contains
    # parenthesis which must be escaped. Here's the play-by-play:
    #
    # Find the dataset and the iocage version for each jail with a recursive
    # zfs list and pipe it to our best friend, awk.
    #
    # Start awk by setting the variable version="${iocage_version}", then do a
    # global string substitution in the BEGIN action to escape the parenthesis
    # around the date in the version string.
    #
    # The first line of input to awk will be ${pool}${iocroot}/jails because of
    # how zfs lists datasets recursively, so we skip that line with FNR > 1.
    #
    # If the line doesn't contain our version string, print the first field,
    # which gives us the dataset with a mismatched version.
    _mismatches=$(zfs get -Hrd1 -o name,value \
                      org.freebsd.iocage:iocage_version \
                      ${pool}${iocroot}/jails \
                         | awk -v version="${iocage_version}" \
                               'BEGIN { gsub(/[()]/, "\\\\&", version) }
                                FNR > 1 && $0 !~ version { print $1 }')

    for _jail in ${_mismatches} ; do
        __update_dataset_ioc_properties ${_jail} &
    done

    wait
}

# Check that our jail is compatible with this version of iocage.
#
# If the jail isn't compatible, make it compatible.
#
# Version is stored per-jail so that when jails are transferred between
# different versions of iocage, we can detect and fix missing properties without
# requiring manual intervention.
__check_dataset_ioc_version () {
    local _dataset _jail_version _uuid

    _dataset=${1}

    _jail_version=$(__get_dataset_ioc_prop iocage_version ${_dataset})

    if [ "${_jail_version}" != "${iocage_version}" ] ; then
        __update_dataset_ioc_properties ${_jail}
    fi
}

# Same as above but for the .defaults dataset.
__check_defaults_ioc_version () {
    local _dataset _jail_version _uuid

    _dataset=${pool}/iocage/.defaults

    _jail_version=$(__get_dataset_ioc_prop iocage_version ${_dataset})

    if [ "${_jail_version}" != "${iocage_version}" ] ; then
        __update_defaults_ioc_properties
    fi
}

# Add missing ioc properties to the .defaults dataset.
#
# When iocage is updated and new properties are added, these properties
# will be missing from existing jails. This function looks for any unset
# properties on the default dataset and sets them to the hardcoded default.
__update_defaults_ioc_properties () {
    local _dataset _CONF _prop _value

    _dataset=${pool}/iocage/.defaults

    echo "Updating default iocage properties" >&2

    _CONF="${CONF_RCTL}
           ${CONF_NET}
           ${CONF_JAIL}
           ${CONF_CUSTOM}
           ${CONF_SYNC}
           ${CONF_FTP}"

    for _prop in ${_CONF} ; do
        _value=$(__get_dataset_ioc_prop ${_prop} ${_dataset})
        if [ "${_value}" == "-" ] ; then
            eval _value=\$${_prop}
            __set_dataset_ioc_prop ${_prop}="${_value}" ${_dataset}
        fi
    done

    __set_dataset_ioc_prop iocage_version="${iocage_version}" ${_dataset}
}

# Add missing ioc properties to an existing jail dataset.
#
# When iocage is updated and new properties are added, these properties
# will be missing from existing jails. This function looks for any unset
# properties and sets them to the default value.
__update_dataset_ioc_properties () {
    local _dataset _uuid _CONF _prop _value

    _dataset=${1}

    _uuid=$(__get_dataset_ioc_prop host_hostuuid ${_dataset})
    echo "Updating iocage properties for ${_uuid}" >&2

    _CONF="${CONF_RCTL}
           ${CONF_NET}
           ${CONF_JAIL}
           ${CONF_CUSTOM}
           ${CONF_SYNC}
           ${CONF_FTP}"

    for _prop in ${_CONF} ; do
        _value=$(__get_dataset_ioc_prop ${_prop} ${_dataset})
        if [ "${_value}" == "-" ] ; then
            _value=$(__get_default_prop ${_prop})
            __set_dataset_ioc_prop ${_prop}="${_value}" ${_dataset}
        fi
    done

    __set_dataset_ioc_prop iocage_version="${iocage_version}" ${_dataset}
}

# Unset a property by inheriting from the parent dataset.
__unset_dataset_zfs_prop () {
    local _property _dataset

    _property=${1}
    _dataset=${2}

    zfs inherit ${_property} ${_dataset}
}

__unset_dataset_ioc_prop () {
    local _property _dataset

    _property=${1}
    _dataset=${2}

    zfs inherit org.freebsd.iocage:${_property} ${_dataset}
}
